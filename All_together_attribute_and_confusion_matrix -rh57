import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.utils import shuffle
from scipy.sparse import coo_matrix
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from mpl_toolkits.axes_grid1 import make_axes_locatable
from sklearn import metrics
from sklearn.metrics import recall_score
from sklearn.metrics import precision_score
from sklearn.metrics import confusion_matrix

assert sys.version_info >= (3, 5)


def correlations(path):
    X = pd.read_csv("/Users/Hookay/Desktop/Weka/Road signs/dataprep/Python/x_train_gr_smpl.csv")
    # import Y
    y = pd.read_csv(path)
    # make sure Y is column
    y = np.ravel(y)
    # insert Y to last column of X
    X.insert(2304, "class", y, allow_duplicates=False)

    # mix the rows
    X = shuffle(X, random_state=0)
    # do the correlation
    corr_matrix = X.corr()
    # get the top 10 values if 5 then head(6) if 20 then head(21) first one is class
    tmp = corr_matrix["class"].sort_values(ascending=False).head(11)
    # get the labels
    names = tmp.keys()
    # get rid of the first value which is class
    b = names[1:]
    # make sure no repetition occurs
    bundle = list(dict.fromkeys(b))
    return bundle


def run():
    # create array to store labels
    bundle = []
    # iterate trough 0-10 to get all the signs
    for i in range(0, 10):
        print("Top 10 most correlated pixels of sign " + str(i) + ":")
        path = "/Users/Hookay/Desktop/Weka/Road signs/deep/Python/y_train_smpl_" + str(i) + ".csv"
        # place the found labels into the bundle array
        bundle.extend(correlations(path))
    # read in data for correlation
    X = pd.read_csv("/Users/Hookay/Desktop/Weka/Road signs/dataprep/Python/x_train_gr_smpl.csv")
    Y = pd.read_csv("/Users/Hookay/Desktop/Weka/Road signs/dataprep/Python/y_train_smpl.csv")
    # make sure both y is in column and bundle is in row shape
    Y = np.ravel(Y)
    bundle = np.ravel(bundle)
    # get the labels mach with X data
    ten = X[bundle]

    # coo_matrix uses three sub-arrays to store the element values and their coordinate positions.row[] column[] data[]
    ten_sparse = coo_matrix(ten)

    # X_sparse to keep track of position and data
    ten, X_sparse, Y = shuffle(ten, ten_sparse, Y, random_state=0)
    # split to train and test
    X_train, X_test, y_train, y_test = train_test_split(ten, Y, test_size=.33, random_state=17)

    y_expect = y_test

    # Multinomial
    y_train = np.ravel(y_train)
    MultiNB = MultinomialNB()
    MultiNB.fit(X_train, y_train)
    y_pred = MultiNB.predict(X_test)

    # ACCURACY
    print("Accuracy:", metrics.accuracy_score(y_expect, y_pred))

    # Recall
    print("Recall:", recall_score(y_expect, y_pred, average=None))

    # Precision
    print("Precision:", precision_score(y_expect, y_pred, average=None))

    # CONFUSION MATRIX
    print(confusion_matrix(y_expect, y_pred))

    cmx = confusion_matrix(y_expect, y_pred)

    # visual interpretation of the confusion matrix with normalisation and miscalculation focus
    def plot_confusion_matrix(cmx, vmax1=None, vmax2=None, vmax3=None):
        cmx_norm = 100 * cmx / cmx.sum(axis=1, keepdims=True)
        cmx_zero_diag = cmx_norm.copy()

        np.fill_diagonal(cmx_zero_diag, 0)

        fig, ax = plt.subplots(ncols=3)
        fig.set_size_inches(12, 3)
        [a.set_xticks(range(6)) for a in ax]
        [a.set_yticks(range(6)) for a in ax]

        im1 = ax[0].imshow(cmx, vmax=vmax1)
        ax[0].set_title('as is')
        im2 = ax[1].imshow(cmx_norm, vmax=vmax2)
        ax[1].set_title('%')
        im3 = ax[2].imshow(cmx_zero_diag, vmax=vmax3)
        ax[2].set_title('% and 0 diagonal')

        dividers = [make_axes_locatable(a) for a in ax]
        cax1, cax2, cax3 = [divider.append_axes("right", size="5%", pad=0.1)
                            for divider in dividers]

        fig.colorbar(im1, cax=cax1)
        fig.colorbar(im2, cax=cax2)
        fig.colorbar(im3, cax=cax3)
        fig.tight_layout()

    plot_confusion_matrix(cmx)

    # the types appear in this order
    print('\n', sorted(np.unique(y_expect)))
